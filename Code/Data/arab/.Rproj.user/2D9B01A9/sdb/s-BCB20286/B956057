{
    "contents" : "function (formula, data, family = \"poisson\", link, start, random, \n          corStruct = \"diag\", easyFlag = TRUE, zeroInflation = FALSE, \n          admb.opts = admbControl(), mcmc = FALSE, mcmc.opts = mcmcControl(), \n          save.dir, verbose = FALSE, extra.args = \"\", bin_loc = NULL, \n          debug = FALSE) \n{\n  file_name <- \"glmmadmb\"\n  if (!missing(easyFlag)) \n    warning(\"easyFlag argument ignored\")\n  res <- get_bin_loc(file_name, debug = debug)\n  platform <- res$platform\n  if (is.null(bin_loc)) \n    bin_loc <- res$bin_loc\n  impSamp <- admb.opts$impSamp\n  maxfn <- admb.opts$maxfn\n  imaxfn <- admb.opts$imaxfn\n  run <- admb.opts$run\n  if (use_tmp_dir <- missing(save.dir)) {\n    repeat {\n      save.dir <- paste(tempfile(pattern = \"glmmADMB\"))\n      if (!file.exists(save.dir)) {\n        if (debug) \n          cat(\"using temp directory\", save.dir, \"\\n\")\n        break\n      }\n    }\n  }\n  if (newdir <- !file_test(\"-d\", save.dir)) {\n    if (debug) \n      cat(\"creating temp directory\\n\")\n    dir.create(save.dir)\n  }\n  owd <- setwd(save.dir)\n  if (debug) \n    cat(\"changed working directory to\", getwd(), \"\\n\")\n  on.exit({\n    setwd(owd)\n    if (debug) cat(\"changed working directory to\", getwd(), \n                   \"\\n\")\n  })\n  if (use_tmp_dir) {\n    on.exit({\n      unlink(save.dir, recursive = TRUE)\n      if (debug) cat(\"removed temp directory\", save.dir, \n                     \"\\n\")\n    }, add = TRUE)\n  }\n  zi_model_flag <- alpha_model_flag <- FALSE\n  if (is.list(formula)) {\n    if (!is.null(zi_model <- formula[[\"zi\"]])) \n      zi_model_flag <- TRUE\n    if (!is.null(alpha_model <- formula[[\"alpha\"]])) \n      alpha_model_flag <- TRUE\n    formula <- if (names(formula)[1] == \"\") \n      formula[[1]]\n    else formula[[\"eta\"]]\n  }\n  if (zi_model_flag || alpha_model_flag) \n    stop(\"models for zero-inflation and dispersion parameters not yet implemented\")\n  call <- match.call()\n  has_rand <- !missing(random) || length(grep(\"\\\\|\", as.character(formula)[3])) > \n    0\n  if (!has_rand && (!missing(corStruct))) \n    stop(\"No random effects specified: \\\"corStruct\\\" does not make sense\")\n  if (!is.character(family)) \n    stop(\"must specify 'family' as a character string\")\n  family <- tolower(family)\n  family <- gsub(\"binomial\", \"binom\", family)\n  nbinom1_flag <- 0\n  if (family %in% c(\"nbinom1\", \"truncnbinom1\")) {\n    nbinom1_flag <- 1\n  }\n  if (length(grep(\"nbinom\", family)) > 0) \n    family <- gsub(\"[12]$\", \"\", family)\n  like_type_flag <- switch(family, poisson = 0, binom = 1, \n                           nbinom = 2, gamma = 3, beta = 4, gaussian = 5, truncpoiss = 6, \n                           truncnbinom = 7, logistic = 8, betabinom = 9, stop(\"unknown family\"))\n  has_alpha <- family %in% c(\"nbinom\", \"gamma\", \"beta\", \"gaussian\", \n                             \"truncnbinom\", \"logistic\", \"betabinom\")\n  if (missing(link)) {\n    link <- switch(family, binom = , beta = , betabinom = \"logit\", \n                   nbinom = , poisson = , truncpoiss = , truncnbinom = , \n                   gamma = \"log\", gaussian = , logistic = \"identity\")\n  }\n  linkfun <- switch(link, log = log, logit = qlogis, probit = qnorm, \n                    inverse = function(x) {\n                      1/x\n                    }, cloglog = function(x) {\n                      log(-log(1 - x))\n                    }, identity = identity, stop(\"unknown link function\"))\n  ilinkfun <- switch(link, log = exp, logit = plogis, probit = pnorm, \n                     inverse = function(x) {\n                       1/x\n                     }, cloglog = function(x) {\n                       pmax(pmin(-expm1(-exp(x)), 1 - .Machine$double.eps), \n                            .Machine$double.eps)\n                     }, identity = identity)\n  link_type_flag <- switch(link, log = 0, logit = 1, probit = 2, \n                           inverse = 3, cloglog = 4, identity = 5)\n  if (missing(data)) \n    data <- environment(formula)\n  mf <- match.call(expand.dots = FALSE)\n  m <- match(c(\"formula\", \"data\", \"subset\", \"na.action\", \"offset\"), \n             names(mf), 0L)\n  mf <- mf[c(1L, m)]\n  mf$formula <- get_fixedformula(eval(mf$formula, parent.frame()))\n  comb_formula <- function(old, new) {\n    if (is.null(new)) \n      return(old)\n    update.formula(old, paste0(\".~.+\", as.character(new)[2]))\n  }\n  if (alpha_model_flag) {\n    mf$formula <- comb_formula(mf$formula, alpha_model)\n  }\n  if (zi_model_flag) {\n    mf$formula <- comb_formula(mf$formula, zi_model)\n  }\n  mf$drop.unused.levels <- TRUE\n  mf[[1L]] <- as.name(\"model.frame\")\n  mf_orig <- mf\n  mf <- eval(mf, parent.frame())\n  mt <- attr(mf, \"terms\")\n  if (is.data.frame(data) && nrow(mf) < nrow(data)) \n    warning(\"NAs removed in constructing fixed-effect model frame: \", \n            \"you should probably remove them manually, e.g. with na.omit()\")\n  y <- model.response(mf, \"any\")\n  if (inherits(y, \"factor\")) {\n    if (family != \"binom\") \n      stop(\"factors as response variables only allowed for binomial models\")\n    y <- 1 - as.numeric(as.numeric(y) == 1)\n  }\n  y <- as.matrix(y)\n  if (family %in% c(\"nbinom\", \"truncnbinom\", \"poisson\", \"truncpoiss\", \n                    \"binom\", \"betabinom\") && any(y != floor(y))) {\n    warning(\"non-integer response values in discrete family\")\n  }\n  if (substr(family, 1, 5) == \"trunc\" && any(y == 0)) {\n    warning(\"zero response values in truncated family\")\n  }\n  n <- nrow(y)\n  p_y <- ncol(y)\n  nyobs <- if (family %in% c(\"binom\", \"betabinom\")) \n    rowSums(y)\n  else 1\n  offset <- as.vector(model.offset(mf))\n  has_offset <- !is.null(offset)\n  if (!has_offset) \n    offset <- rep(0, n)\n  X <- model.matrix(mt, mf)\n  p <- ncol(X)\n  if ((rankX <- rankMatrix(X)) < p) \n    stop(gettextf(\"rank of X = %d < ncol(X) = %d\", rankX, \n                  p))\n  zi_p <- 1\n  zi_X <- matrix(0, 1, 1)\n  if (zi_model_flag) {\n    zi_X <- model.matrix(zi_model, mf)\n    zi_p <- ncol(zi_X)\n  }\n  alpha_p <- 1\n  alpha_X <- matrix(0, 1, 1)\n  if (alpha_model_flag) {\n    alpha_X <- model.matrix(alpha_model, mf)\n    alpha_p <- ncol(alpha_X)\n  }\n  if (has_rand) {\n    REmat <- process_randformula(formula, random, data = data)\n    if (any(REmat$nterms > 1)) {\n      tmpind <- rep(seq_along(REmat$mmats), REmat$nterms)\n      REmat$mmats <- REmat$mmats[tmpind]\n      names(REmat$mmats) <- names(REmat$levels)\n      REmat$codes <- unlist(lapply(REmat$codes, function(x) lapply(as.list(as.data.frame(x)), \n                                                                   matrix)), recursive = FALSE)\n    }\n    m <- sapply(REmat$mmats, ncol)\n    M <- length(m)\n    corStruct <- rep(corStruct, length.out = M)\n    m2 <- ifelse(corStruct == \"diag\", m, m * (m + 1)/2)\n    q <- sapply(REmat$levels, length)\n    Z <- do.call(cbind, REmat$mmats)\n    colnames(Z) <- paste(rep(names(REmat$mmat), m), unlist(sapply(REmat$mmat, \n                                                                  colnames)), sep = \".\")\n    II <- matrix(rep(q, m), nrow = n, ncol = sum(m), byrow = TRUE)\n    if (sum(m) > 1) \n      for (i in 2:sum(m)) II[, i] = II[, i] + II[, i - \n                                                   1]\n    II <- cbind(0, II[, -ncol(II)])\n    ii <- 1\n    for (i in 1:M) for (j in 1:m[i]) {\n      II[, ii] = II[, ii] + REmat$codes[[i]]\n      ii = ii + 1\n    }\n    cor_block_start = cumsum(m) - m[1] + 1\n    cor_block_stop = cumsum(m)\n    numb_cor_params = max(sum(m * (m - 1)/2), 1)\n  }\n  else {\n    m <- M <- q <- 1\n    Z <- matrix(0, ncol = 1, nrow = n)\n    II <- matrix(rep(q, m), nrow = n, ncol = sum(m), byrow = TRUE)\n    cor_block_start <- cor_block_stop <- 1\n    numb_cor_params <- 1\n  }\n  cmdoptions <- paste(\"-maxfn\", maxfn)\n  if (!is.null(admb.opts$maxph) && !is.na(admb.opts$maxph)) \n    cmdoptions <- paste(cmdoptions, \"-maxph\", admb.opts$maxph)\n  if (admb.opts$noinit) \n    cmdoptions <- paste(cmdoptions, \"-noinit\")\n  if (admb.opts$shess) \n    cmdoptions <- paste(cmdoptions, \"-shess\")\n  if (has_rand && impSamp > 0) \n    cmdoptions <- paste(cmdoptions, \"-is\", impSamp)\n  if (mcmc) \n    cmdoptions <- paste(cmdoptions, mcmcArgs(mcmc.opts))\n  if (!missing(extra.args)) \n    cmdoptions <- paste(cmdoptions, extra.args)\n  cor_flag <- as.numeric(corStruct == \"full\")\n  dat_list <- list(n = n, p_y = p_y, y = y, p = p, X = X, M = M, \n                   q = q, m = m, ncolZ = ncol(Z), Z = Z, II = II, cor_flag = cor_flag, \n                   cor_block_start = cor_block_start, cor_block_stop = cor_block_stop, \n                   numb_cor_params = numb_cor_params, like_type_flag = like_type_flag, \n                   link_type_flag = link_type_flag, rlinkflag = 1L, no_rand_flag = as.numeric(!has_rand), \n                   zi_flag = as.numeric(zeroInflation), zi_kluge = as.numeric(admb.opts$ZI_kluge), \n                   poiss_prob_bound = as.numeric(admb.opts$poiss_prob_bound), \n                   nbinom1_flag = as.numeric(nbinom1_flag), intermediate_maxfn = imaxfn, \n                   has_offset = as.numeric(has_offset), offset = offset)\n  pz_start <- c(if (zeroInflation) 0.02 else 1e-04, rep(0, \n                                                        zi_p - 1))\n  log_alpha_start <- c(1, rep(0, alpha_p - 1))\n  pin_list <- list(pz = pz_start, b = numeric(p), tmpL = 0.25 + \n                     numeric(sum(m)), tmpL1 = 1e-04 + numeric(numb_cor_params), \n                   log_alpha = log_alpha_start, u = rep(0, sum(m * q)))\n  if (!missing(start) && !is.null(start$fixed)) {\n    phi <- make_phi(X)\n    start$fixed <- start$fixed %*% solve(phi)\n  }\n  rnames <- list(c(\"fixed\", \"b\"), c(\"RE_sd\", \"tmpL\"), c(\"RE_cor\", \n                                                        \"tmpL1\"), c(\"pz\", \"pz\"), c(\"log_alpha\", \"log_alpha\"))\n  if (!missing(start)) {\n    for (i in seq_along(rnames)) {\n      names(start)[names(start) == rnames[[i]][1]] <- rnames[[i]][2]\n    }\n    ns <- names(start)\n    for (i in seq_along(start)) {\n      pp <- pin_list[[ns[i]]]\n      if (is.null(pp)) {\n        stop(\"unmatched start component \", ns[i])\n      }\n      if (length(pp) != length(start[[i]])) {\n        stop(\"length mismatch in start component \", ns[i], \n             \": \", length(pp), \"!=\", length(start[[i]]))\n      }\n      pin_list[[ns[i]]] <- start[[i]]\n    }\n  }\n  dat_write(file_name, dat_list)\n  pin_write(file_name, pin_list)\n  par_file <- paste0(file_name, \".par\")\n  std_file <- paste0(file_name, \".std\")\n  if (file.exists(std_file) && run) \n    warning(\"file \", std_file, \" exists: overwriting\")\n  sys.result <- run_bin(platform, bin_loc, file_name, cmdoptions, \n                        run, rm_binary = !use_tmp_dir, debug = debug, verbose = verbose)\n  if (!file.exists(std_file)) {\n    if (run) {\n      if (file.exists(par_file)) {\n        message(\"Parameters were estimated, but not standard errors were not: \", \n                \"the most likely problem is that the curvature at MLE was zero or negative\")\n      }\n      stop(\"The function maximizer failed (couldn't find STD file)\", \n           \" Troubleshooting steps include (1) run with 'save.dir' set \", \n           \"and inspect output files; (2) change run parameters: see '?admbControl'\")\n    }\n    message(\"'run=FALSE' specified, STD file not found: stopping\")\n    return(NULL)\n  }\n  tmp <- read.table(paste(file_name, \"std\", sep = \".\"), skip = 1, \n                    as.is = TRUE)\n  tmpindex <- tmp[, 2]\n  out <- list(n = n, q = q, formula = formula, fixed = get_fixedformula(formula), \n              call = call, frame = mf, terms = mt, family = family, \n              corStruct = corStruct, impSamp = impSamp, easyFlag = easyFlag, \n              zeroInflation = zeroInflation)\n  if (zeroInflation) {\n    out$pz <- as.numeric(tmp[tmpindex == \"pz\", 3])\n    out$sd_pz <- as.numeric(tmp[tmpindex == \"pz\", 4])\n  }\n  out$b <- as.numeric(tmp[tmpindex == \"real_beta\", 3])\n  out$stdbeta <- as.numeric(tmp[tmpindex == \"real_beta\", 4])\n  names(out$stdbeta) <- names(out$b) <- colnames(X)\n  if (has_alpha) {\n    out$alpha <- as.numeric(tmp[tmpindex == \"alpha\", 3])\n    out$sd_alpha <- as.numeric(tmp[tmpindex == \"alpha\", 4])\n  }\n  out$offset <- offset\n  out$link <- link\n  out$linkfun <- linkfun\n  out$ilinkfun <- ilinkfun\n  if (has_rand) {\n    Svec <- tmp[tmpindex == \"S\", 3]\n    parnames <- lapply(REmat$mmat, colnames)\n    groupnames <- names(REmat$mmats)\n    dn <- mapply(list, parnames, parnames, SIMPLIFY = FALSE)\n    mkmat <- function(x, n, dimnames) {\n      if (length(x) == 1) {\n        m <- matrix(x)\n      }\n      else if (length(x) == n) {\n        m <- diag(x)\n      }\n      else {\n        m <- matrix(NA, nrow = n, ncol = n)\n        m[lower.tri(m, diag = TRUE)] <- x\n        m[upper.tri(m)] <- t(m)[upper.tri(m)]\n      }\n      dimnames(m) <- dimnames\n      m\n    }\n    out$S <- mapply(mkmat, split(Svec, rep(1:length(m), m2)), \n                    n = m, dimnames = dn, SIMPLIFY = FALSE)\n    sd_Svec <- tmp[tmpindex == \"S\", 4]\n    out$sd_S <- mapply(mkmat, split(sd_Svec, rep(1:length(m), \n                                                 m2)), n = m, dimnames = dn, SIMPLIFY = FALSE)\n    names(out$S) <- names(out$sd_S) <- groupnames\n    uvec <- tmp[tmpindex == \"u\", 3]\n    ulist <- split(uvec, rep(1:length(q), q * m))\n    dn <- mapply(list, REmat$levels, parnames, SIMPLIFY = FALSE)\n    out$U <- mapply(matrix, ulist, ncol = m, nrow = q, dimnames = dn, \n                    SIMPLIFY = FALSE)\n    names(out$U) <- groupnames\n    ii <- 1\n    allU <- matrix(nrow = n, ncol = sum(m))\n    for (i in 1:length(m)) {\n      allU[, ii:(ii + m[i] - 1)] <- out$U[[i]][c(REmat$codes[[i]]), \n                                               ]\n      ii <- ii + m[i]\n    }\n    sd_uvec <- tmp[tmpindex == \"u\", 4]\n    sd_ulist <- split(sd_uvec, rep(1:length(q), q * m))\n    out$sd_U <- mapply(matrix, sd_ulist, ncol = m, nrow = q, \n                       dimnames = dn, SIMPLIFY = FALSE)\n  }\n  else {\n    out$U <- out$sd_U <- matrix(rep(0, q), ncol = 1, byrow = TRUE)\n  }\n  mu <- as.numeric(X %*% out$b) + offset\n  if (has_rand) {\n    sdvals <- unlist(lapply(out$S, function(z) sqrt(diag(z))))\n    eta <- mu + rowSums(Z * sweep(allU, 2, sdvals, \"*\"))\n  }\n  else eta <- mu\n  lambda <- ilinkfun(eta)\n  out$fitted <- lambda\n  if (zeroInflation) {\n    out$fitted <- out$fitted * (1 - out$pz)\n  }\n  out$sd.est <- with(out, switch(family, poisson = sqrt(lambda), \n                                 nbinom = sqrt(lambda * (1 + lambda/alpha)), nbinom1 = sqrt(lambda * \n                                                                                              alpha), betabinom = , binom = sqrt(fitted * (1 - \n                                                                                                                                             fitted)/nyobs), beta = sqrt(fitted * (1 - fitted)/(1 + \n                                                                                                                                                                                                  alpha)), rep(NA, length(lambda))))\n  if (family %in% c(\"binom\", \"betabinom\") && p_y > 1) {\n    out$residuals <- y[, 1]/nyobs - lambda\n  }\n  else out$residuals <- y - lambda\n  tmp <- par_read(file_name)\n  out$npar <- tmp$npar\n  bpar <- bar_read(file_name, n = tmp$npar + 1)[-1]\n  if (file.exists(\"phi.rep\")) {\n    out$phi <- matrix(scan(\"phi.rep\", quiet = TRUE), nrow = length(out$b), \n                      byrow = TRUE)\n    newb <- bpar[seq_along(out$b)] %*% out$phi\n    out$b[] <- newb\n  }\n  out$loglik <- tmp$loglik\n  out$gradloglik <- tmp$gradient\n  nfixpar <- length(out$b)\n  out$corMat <- tmp$cor[1:nfixpar, 1:nfixpar]\n  out$conv <- 0\n  out$convmsg <- \"\"\n  if (abs(out$gradloglik) >= 0.001) {\n    out$convmsg <- paste(\"log-likelihood of gradient=\", out$gradloglik)\n    out$conv <- 1\n    warning(\"Convergence failed:\", out$convmsg)\n  }\n  if (mcmc) {\n    out$mcmc <- as.matrix(R2admb:::read_psv(file_name))\n    colnames(out$mcmc) <- R2admb:::rep_pars(tmpindex)[1:ncol(out$mcmc)]\n    out$mcmc <- mcmc_transform(out$mcmc, out$phi, fnames = names(out$b))\n  }\n  if (has_rand) \n    out$random <- REmat$rstring\n  class(out) <- \"glmmadmb\"\n  return(out)\n}",
    "created" : 1395188103921.000,
    "dirty" : true,
    "encoding" : "",
    "folds" : "",
    "hash" : "3888898389",
    "id" : "B956057",
    "lastKnownWriteTime" : 8030604583819502177,
    "path" : null,
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}